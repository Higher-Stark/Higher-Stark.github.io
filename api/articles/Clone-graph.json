{"title":"Clone graph","slug":"Clone-graph","date":"2018-11-19T14:27:04.000Z","updated":"2018-11-19T15:16:46.459Z","comments":true,"path":"api/articles/Clone-graph.json","photos":[],"link":"","excerpt":"Clone GraphProblem DescriptionGiven the head of a graph, return a deep copy (clone) of the graph. Each node in the graph contains a label (int) and a list (List[UndirectedGraphNode]) of its neighbors. There is an edge between the given node and each of the nodes in its neighbors.根据给定的图的head节点，返回对这个图的深拷贝。<br>图的节点由一个int类型的label和一个相邻UndirectedGraphNode的指针构成的列表neighbors组成。一个节点和他neighbors内的每个节点之间都有一条边相连。<br>","covers":null,"content":"<h1 id=\"Clone-Graph\"><a href=\"#Clone-Graph\" class=\"headerlink\" title=\"Clone Graph\"></a>Clone Graph</h1><h2 id=\"Problem-Description\"><a href=\"#Problem-Description\" class=\"headerlink\" title=\"Problem Description\"></a>Problem Description</h2><blockquote>\n<p>Given the head of a graph, return a deep copy (clone) of the graph. Each node in the graph contains a label (int) and a list (List[UndirectedGraphNode]) of its neighbors. There is an edge between the given node and each of the nodes in its neighbors.</p>\n</blockquote>\n<p>根据给定的图的head节点，返回对这个图的深拷贝。<br>图的节点由一个int类型的label和一个相邻UndirectedGraphNode的指针构成的列表neighbors组成。一个节点和他neighbors内的每个节点之间都有一条边相连。<br><a id=\"more\"></a></p>\n<blockquote>\n<p>As an example, consider the serialized graph <code>{0,1,2#1,2#2,2}</code>.<br>Visually, the graph looks like the following:</p>\n<pre><code>   1\n  / \\\n /   \\\n0 --- 2\n     / \\\n     \\_/\n</code></pre></blockquote>\n<h2 id=\"Analysis\"><a href=\"#Analysis\" class=\"headerlink\" title=\"Analysis\"></a>Analysis</h2><h3 id=\"Serialized-graph\"><a href=\"#Serialized-graph\" class=\"headerlink\" title=\"Serialized graph\"></a>Serialized graph</h3><p>第一眼看到图的序列化还是有点懵逼的，<del>明显下面那样用连线来表示才更直观</del>。<br>多读几遍题就渐渐明白了（图序列化的英文描述请自行前往Leetcode），<code>{ ... }</code>表示一个图，里面用<code>#</code>分割成一个一个节点。就示例<code>{0,1,2#1,2#2,2}</code>而言，这个图里有两个<code>#</code>，即三个节点，符号分别是0,1,2. <code>,</code>表示节点相连，在示例中，第一个<code>#</code>前的部分<code>0,1,2</code>表示节点0与节点1和节点2相连，但不表示节点1与2一定相连，第一个<code>#</code>和第二个<code>#</code>中间的<code>1,2</code>才表示节点1和节点2相连。</p>\n<p>另外再根据测试用例多说一些图序列化。<code>{0,1,1#...}</code>表示节点0和节点1之间有两条边，无法说明节点1自身是否构成自环。<br>从图的代码实现角度来看图的序列化，<code>#</code>将序列分成多个子串，每个子串有至少一个整数，为该节点的符号，后续的整数则表示该节点邻接的节点符号，如果两点之间存在多条边，邻接的点就会重复出现。</p>\n<h3 id=\"Deep-clone\"><a href=\"#Deep-clone\" class=\"headerlink\" title=\"Deep clone\"></a>Deep clone</h3><p>Deep clone is not difficult to implement for this problem. when deep clone a node, remember to clone its neighbors as well. If some neighbor has already been cloned, just pick the cloned one.</p>\n<h2 id=\"Code-implementation\"><a href=\"#Code-implementation\" class=\"headerlink\" title=\"Code implementation\"></a>Code implementation</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Definition for undirected graph.</span></span><br><span class=\"line\"><span class=\"comment\"> * struct UndirectedGraphNode &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> *     int label;</span></span><br><span class=\"line\"><span class=\"comment\"> *     vector&lt;UndirectedGraphNode *&gt; neighbors;</span></span><br><span class=\"line\"><span class=\"comment\"> *     UndirectedGraphNode(int x) : label(x) &#123;&#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">UndirectedGraphNode *<span class=\"title\">cloneGraph</span><span class=\"params\">(UndirectedGraphNode *node)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!node) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::<span class=\"built_in\">map</span>&lt;<span class=\"keyword\">int</span>, UndirectedGraphNode *&gt; visited;</span><br><span class=\"line\">        UndirectedGraphNode *ret = cloneNode(node, visited);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">UndirectedGraphNode *<span class=\"title\">cloneNode</span><span class=\"params\">(UndirectedGraphNode *node, <span class=\"built_in\">std</span>::<span class=\"built_in\">map</span>&lt;<span class=\"keyword\">int</span>, UndirectedGraphNode *&gt; &amp;visited)</span> </span>&#123;</span><br><span class=\"line\">        UndirectedGraphNode *ret = <span class=\"keyword\">new</span> UndirectedGraphNode(node-&gt;label);</span><br><span class=\"line\">        visited.insert(<span class=\"built_in\">std</span>::pair&lt;<span class=\"keyword\">int</span>, UndirectedGraphNode *&gt;(node-&gt;label, ret));</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"built_in\">vector</span>&lt;UndirectedGraphNode *&gt;::iterator it = node-&gt;neighbors.begin(); it != node-&gt;neighbors.end(); it++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (visited.find((*it)-&gt;label) == visited.end()) &#123;</span><br><span class=\"line\">                UndirectedGraphNode *tmp = cloneNode(*it, visited);</span><br><span class=\"line\">                ret-&gt;neighbors.push_back(tmp);</span><br><span class=\"line\">                visited.insert(<span class=\"built_in\">std</span>::pair&lt;<span class=\"keyword\">int</span>, UndirectedGraphNode *&gt;((*it)-&gt;label, tmp));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                ret-&gt;neighbors.push_back(visited[(*it)-&gt;label]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><em>It is obvious that recursion works fine, implicitly implemented DFS.</em></p>\n","categories":[{"name":"Algorithm","slug":"Algorithm","count":3,"path":"api/categories/Algorithm.json"}],"tags":[{"name":"leetcode","slug":"leetcode","count":3,"path":"api/tags/leetcode.json"},{"name":"DFS","slug":"DFS","count":2,"path":"api/tags/DFS.json"}]}